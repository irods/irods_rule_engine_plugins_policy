## Motivation

The process for creating and deploying policy for iRODS requires the rule author to have a complete understanding of the API for iRODS as well as the associated plugin architecture in order to properly leverage the dynamic policy enforcement.  The author will may need to invoke the same policy across several policy enforcement points in order to cover all possible means to move data into iRODS for both object and POSIX data movement.  The goal of this framework is to streamline the crafting and deployment of policy, as well as provide a reusable body of policy that may be easily configured.  Policy should now be a matter of configuration and not hand crafted code which may follow a documented means of deployment for most use cases.

![policy_graphic](policylayer_graphic_uniq.png)

## The Policy Interface

All policy to be invoked by this system must conform to a simple interface of two parameters which are serialized JSON strings, known as the `parameters` and the `configuration`.  This policy may be implemented in any rule language or as a simple rule engine plugin.

For example, in the iRODS Rule Language
```c++
irods_policy_example_policy_implementation(*parameters, *configuration) {
    writeLine("stdout", "Hello, World!")
}
```

Or in the Python rule language:
```python
def irods_policy_example_policy_implementation(rule_args, callback, rei):
# Parameters    rule_args[1]
# Configuration rule_args[2]
```

The `parameters` contain all the information captured by the event handler, or may be passed in as a prepopulated JSON object when configured.  These values may change depending on how the policy is configured and the contract between the policy and the event handlers used.  The `configuration` may contain any other pertinent information that the policy may need at the time of invocation.  This is a way to externalize any variables the policy may leverage, such as the given attribute to use for metadata application.

Policy may be invoked directly, by an event handler or by the Query Processor which will be discussed later.

## Event Handlers

Event handlers are a classification of rule engine plugin which consume dynamic policy enforcement points related to a noun within iRODS and invoke policy configured for events generated by the plugin.  There will exist one event handler per noun in the system. The first two to be implemented are for Data Objects and Metadata.

The complete list is:
  * Data Objects
  * Collections
  * Metadata
  * Resources
  * Users and Groups

The policy to be invoked is a matter of the plugin specific configuration within `/etc/irods/server_config.json` for a given instance of an event handler.  The `"plugin_specific_configuration"` object for the given instance will look for a JSON array `"policies_to_invoke"`, which itself is a series of JSON objects.  These objects are the configuration of a policy to invoke for a given series of events.  The policy objects contain:
  * conditional
  * active_policy_clauses
  * events
  * policy_to_invoke

### Conditional
A conditional describes a set of conditions which must be met in order to invoke the policy.  These are a series of regular expressions which match the nouns involved.  This could be the `logical_path`, `metadata_applied`, `metadata_exists`, `user_name`, `source_resource`, or `destination_resource`.  The metadata conditionals are separated into two flavors, one for the application of metadata and one for invoking policy based on the existence of metadata.  The `metadata_exists` conditional will test for the existence of matching metadata on any `entity_type` configured.  The "entity_type" for the metadata maps to the iRODS nouns which are: `"data_object", "collection", "resource", and "user"`.  To match metadata that may exist anywhere in a logical path, a `recursive` flag may be set to walk the path looking for matching metadata.

An example might be:
```json
"conditional" : {
    "logical_path" : "/tempZone/home/*",
    "metadata_applied" : {
        "attribute" : "foo*",
        "value" : "bar*",
        "units" : "baz*",
        "entity_type" : "data_object"
    }
}
```

An example for matching metadata in a logical path used to invoke an indexing event:
```json
"conditional" : {
    "logical_path" : "/tempZone/home/*",
    "metadata_exists" : {
        "recursive" : "true",
        "attribute" : "irods::indexing::index",
        "value" : "elasticsearch::full_text",
        "entity_type" : "data_object"
    }
}
```

An example matching data objects put into a destination resource:
```json
"conditional" : {
    "logical_path" : "/tempZone/home/*",
    "destination_resource " : "dest_resc_*"
}
```
### Active Policy Clauses
`"active_policy_clauses"` is configured as a JSON array of one or more of the following: `"pre", "post", "except", "finally"` which map to which dynamic policy enforcement points are invoked at which point in the operation flow. For example:

`"active_policy_clauses" : ["post"],`

### Events
`"events"` is also configured as a JSON array of strings which map to the events generated by the event handler. Each event handler will have its own set of events for which it may invoke policy which are documented below.  For a data object modified example where data is ingested:
`"events" : ["create", "write", "registration"],`

### Policy to Invoke
`"policy_to_invoke"` is a JSON string which is the name of the policy to invoke.  Following the policy is a "configuration" object which contains any specific information related to that given policy.  An example for data replication:
```
"policy_to_invoke" : "irods_policy_data_replication",
"configuration" : {
    "source_to_destination_map" : {
        "edge_resource_0" : ["long_term_resource_0"],
        "edge_resource_1" : ["long_term_resource_1"],
}
```

## Data Object Modified Event Handler
The Data Object event handler unifies both the Object and POSIX semantics, as well as other iRODS specific operations such as registration, into a single point of truth for invoking policy related to data access.  The plugin maps policy enforcement points to specific set of events for which policy may be configured.  The event handler provides events for all operations related to data objects:

* CREATE
* CHECKSUM
* COPY
* CREATE
* CREATE
* GET
* SEEK
* REPLICATION
* PUT
* RENAME
* REPLICATION
* TRIM
* TRUNCATE
* UNLINK
* REGISTER

The data object modified event handler captures all variables within the dataObjInp_t and rsComm_t which are then seralized to JSON and passed to the invoked policy.  Additional information such as the event, associated policy enforcement point are also included.
```json
{
"comm":{
    "auth_scheme":"native","client_addr":"152.54.8.141","proxy_auth_info_auth_flag":"5","proxy_auth_info_auth_scheme":"",
    "proxy_auth_info_auth_str":"","proxy_auth_info_flag":"0","proxy_auth_info_host":"","proxy_auth_info_ppid":"0",
    "proxy_rods_zone":"tempZone","proxy_sys_uid":"0","proxy_user_name":"rods","proxy_user_other_info_user_comments":"",
    "proxy_user_other_info_user_create":"","proxy_user_other_info_user_info":"","proxy_user_other_info_user_modify":"",
    "proxy_user_type":"","user_auth_info_auth_flag":"5","user_auth_info_auth_scheme":"","user_auth_info_auth_str":"",
    "user_auth_info_flag":"0","user_auth_info_host":"","user_auth_info_ppid":"0","user_rods_zone":"tempZone",
    "user_sys_uid":"0","user_user_name":"rods","user_user_other_info_user_comments":"","user_user_other_info_user_create":"",
    "user_user_other_info_user_info":"","user_user_other_info_user_modify":"","user_user_type":""
    },
"cond_input":{
    "dataIncluded":"","dataType":"generic","destRescName":"ufs0","noOpenFlag":"","openType":"1",
    "recursiveOpr":"1", "resc_hier":"ufs0","selObjType":"dataObj","translatedPath":""
    },
"create_mode":"33204",
"data_size":"1",
"event":"CREATE",
"num_threads":"0",
"obj_path":"/tempZone/home/rods/test_put_gt_max_sql_rows/junk0083",
"offset":"0",
"open_flags":"2",
"opr_type":"1",
"policy_enforcement_point":"pep_api_data_obj_put_post"
}
```

## Metadata Modified Event Handler
The metadata modifed event handler reacts to the interaction of a client with the user defined metadata within the catalog and generates one event: `METADATA`.  It provides a parameter object of the following form:

```json
{
    "metadata" : {
        "operation"   : "",
        "entity_type" : "",
        "attribute"   : "",
        "value"       : "",
        "units"       : ""
    },
    "logical_path" : "",
    "source_resource" : "",
    "user_name" : ""
}
```
Where `logical_path`, `source_resource`, and `user_name` are optional depending on the target of the metadata operation.  `entity_type` may be one of `data_object`, `collection`, `resource` or `user`.  And, `"operation"` may be one of the following: `set`, `add`, or `remove`.

## Collection Event Handler
The collection event handler emits three operations: `CREATE`, `REMOVE`, and `REGISTER`.  For the `REGISTER` operation it provides a parameters object identical to the *Data Object Modified* event handler including the dataObjInp_t and rcComm_t.  For the `CREATE` and `REMOVE` operations the collInp_t is serialized which provides: `logical_path`, `flags`, `opr_type`, and the `cond_input`.

## Administration Event Handlers: Resource, User, Group and Zone
Interaction with the other nouns in the sytem is performed solely through the general administration API endpoint, which allows for these event handlers to provide identical configuraiton and behavior.  The events emitted are `CREATE`, `MODIFY` and `REMOVE`.  The generalAdminInp_t is serialized which provides `action`, `target`, and `arg2` through `arg9` which contain various information depending on the action and target in question.  Additionall, depending on the target `user_name`, `group_name`, `source_resource` or `zone` will be present.

## Policy Engines

The policy engine framework provides a set of utilities for the creation of a light rule engine plugin which implements a policy that conforms to the Event Handler interface.  It is a goal that the community continues to capture policy which may be reflected as reusable components within this framework.

### Query Processor

The `irods_policy_query_processor` policy engine wraps the query_processor library within the iRODS development environment.  This policy engine will invoke a configured policy for every resulting row from the given query.  Each resulting row is passed to the invoked policy via the parameters as a JSON array `query_results`.  The data within the array arrives in the same order as the columns selected witin the query.

```json
"query_string" : "SELECT USER_NAME, COLL_NAME, DATA_NAME, RESC_NAME WHERE COLL_NAME = '/tempZone/home/rods' AND DATA_NAME = 'test_put_file'",
"query_limit" : 1,
"query_type" : "general",
"number_of_threads" : 1,
"policy_to_invoke" : "irods_policy_testing_policy",
"configuration" : {
}
```
